- MySQL
  :LOGBOOK:
  CLOCK: [2023-10-07 Sat 13:05:28]
  :END:
	- DONE 看面试题
	  :LOGBOOK:
	  CLOCK: [2023-10-10 Tue 11:46:55]
	  CLOCK: [2023-10-10 Tue 11:46:59]--[2023-10-10 Tue 21:24:01] =>  09:37:02
	  :END:
	- https://www.bilibili.com/video/BV1N24y1y7a1
	- [[如何实现的索引机制]]
	- [[表中没有索引，会创建B+树吗]]
	- [[B+树]]
	- [[为什么官方推荐自增主键]]
	- [[使用int作为自增主键，最大id为10，删除10和9，添加一条记录，不重启和重启后添加记录id为多少]]
	- [[索引优缺点]]
	- [[回表操作]]
	- [[索引类型]]
	- [[创建索引的情况]]
	- [[索引下推]]
	- [[索引失效]]
	- [[多个索引是否可以指定]]
	- [[Order By是否走索引]]
	- [[MySQL查询缓存]]
	- [[MySQL组成]]
	- [[MySQL执行SQL步骤]]
	- [[存储引擎]]
	- [[MySQL事务]]
	- [[MySQL锁]]
	- [[XA协议]]
	- [[select for update会产生哪些操作]]
	- [[死锁的产生原因和处理方法]]
	- [[MySQL日志]]
	- MySQL开发
		- [[可以用MySQL存储文件吗]]
		- [[存储的时候有遇到过什么问题吗]]
		- [[财务计算有没有出现过错乱]]
		- [[预编译SQL]]
		- [[子查询和join哪个效率高]]
		- [[SQL调优]]
		- [[MySQL数据库cpu飙升]]
		- [[分库分表]]
		- [[视图]]
		- [[存储过程]]
		- [[外键]]
		- [[processlist]]
		- [[千万数据查询优化]]
		- [[count(列名)和count(*)区别]]
		- [[如果有超大分页怎么处理]]
		- [[mysql服务器毫无规律异常重启]]
		- [[mysql线上修改表结构有哪些风险]]
		- [[什么是mysql多实例部署]]
- DOING 多线程
  :LOGBOOK:
  CLOCK: [2023-10-07 Sat 13:11:17]
  :END:
	- [[Java创建线程的方式有哪些]]
	- [[线程生命周期状态]]
	- [[什么是线程安全，线程安全的本质]]
	- [[ThreadLocal使用场景]]
	- [[ThreadLocal内存泄漏]]
	- [[Java中21种锁]]
	- [[为什么阿里禁用Executors创建线程]]
	- [[如何根据实际需要，定制自己的线程池]]
	- [[CAS缺点]]
	- [[线程池线程复用原理]]
	- [[阻塞和非阻塞队列的并发安全原理]]
	- [[公平锁和非公平锁]]
	- [[自旋锁优缺点]]
	- [[合适的线程数量，CPU核心数和线程数的关系]]
	- [[CAS是一种什么样的同步机制]]
	- [[线程加锁有哪些方式，Synchronized和lock的区别]]
	- [[进程和线程的区别，使用线程真的能节省时间]]
	- [[线程有几种状态]]
	- [[ThreadLocal是什么，工作中有用到过吗]]
	- [[ThreadLocal如何实现]]
	- [[ThreadLocal父子线程怎么共享数据]]
	- [[ThreadLocalMap的结构及扩容机制]]
	- [[解决hash冲突方法]]
	- [[你知道哪几种锁，分别有什么特点]]
	- [[什么是阻塞队列，Java中有哪些阻塞队列]]
	- [[ConcurrentHashMap为什么放弃了分段锁]]
	- [[HashMap内部如何工作]]
	- [[什么是指令重排序，为什么要重排序]]
	- [[什么是内存可见性]]
	- [[主内存和工作内存的关系]]
	- [[什么是happen-before原则]]
	- [[为什么需要AQS，AQS的作用和重要性]]
	- [[一个线程调用两次start()方法会出现什么情况]]
	- [[为什么多线程会带来性能问题]]
	- [[线程池有几种拒绝策略]]
	- [[哪些解决死锁的策略]]
	- [[你知道哪些线程安全问题]]
	- [[线程池中提交一个任务是怎么样的]]
- DONE JVM
  :LOGBOOK:
  CLOCK: [2023-10-07 Sat 13:11:28]--[2023-10-17 Tue 20:44:40] =>  247:33:12
  :END:
	- https://www.bilibili.com/video/BV1dA411U7or
	- [[JVM主要组成部分]]
	- [[JVM内存结构]]
	- [[垃圾回收算法]]
	- [[垃圾回收器]]
	- [[JVM调优]]
	- [[JDK自带调优工具]]
	- [[生产环境OOM问题]]
	- [[生产环境CPU飙高问题]]
	- [[类加载机制]]
	- [[对象完整创建流程]]
	- [[对象分配内存时的指针碰撞和空闲列表机制]]
	- [[对象头]]
	- [[对象分配内存时的并发问题解决CAS与TLAB机制]]
	- [[如何计算对象占用内存大小]]
	- [[对象指针压缩]]
	- [[栈上分配，逃逸分析，标量替换]]
	- [[引用计数法有什么问题]]
	- [[GC Root可达性分析法]]
	- [[什么样的类能被回收]]
	- [[JVM内部各种垃圾收集算法]]
	- [[CMS垃圾回收过程]]
	- [[CMS比较严重的问题并发收集阶段再次触发Full GC]]
	- [[垃圾收集底层三色标记算法]]
	- [[G1垃圾收集过程]]
	- [[G1收集器最大停顿时间时如何实现的]]
	- [[内存泄漏如何排查和解决]]
	- [[GC什么时候都能做吗，GC安全点和安全区域]]
	- [[字符串常量池]]
	- [[基本类型包装类常量池如何实现的]]
	- 堆的分代
		- 年轻代minor gc
			- Eden
			- S0
			- S1
		- 老年代full gc
	- 可达性分析法
		- GCRoots，以root为节点分析引用的对象
	- jvisualvm
		- 双击进去查看内部的运行情况
	- arthas
		- java -jar运行jar包
		- dashboard
		- thread 线程号
			- 定位代码运行位置
		- thread -b
			- 查看死锁
		- jad
			- 反编译代码
		- ognl
			- 修改线上系统变量的值
	- STW机制
		- 用户线程会被暂停
	- 电商网站
		- 有压力频繁full gc
		- 亿级流量电商
			- 每个用户平均点击20，30次
			- 日活用户500万
			- 付费转换率10%
			- 日均50万单
			- 大促在抢购前几分钟产生
			- 每秒1000多单
		- 4核8G部署 300单/秒
			- 一个订单对象1KB
			- 每秒300KB订单
			- 其他对象放大20倍
			- eden800M，s0，s1，100M，old2G
			- 一秒产生60M对象，运行14秒占满eden
			- 因为动态对象年龄，每秒60M对象直接移动到老年代
	- 能够对JVM调优，让其不发生Full GC
		- 可以，调大新生代的区域大小，让清理的时间延长
	- 长期存活对象移动到老年代
		- 动态对象年龄
			- 一批对象的总大小大于这块susrvivor区域内存大小的50%，大于等于这批对象年龄最大值的对象可以直接进入老年代
			-