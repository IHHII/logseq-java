- 每个页大小为16K，页的结构：
	- 页标识
	- 最小记录record_type=2
	- 最大记录record_type=3
	- 普通记录record_type=0，1是B+树非叶子节点记录
	- recore_type+next_record+c1列+c2列+c3列+其他信息（该id所在页）
- 非叶子节点不存储数据，之存储主键，页之间使用双向链表连接，方便范围和反向排序查询
- 聚簇索引
	- 主键作为索引的值
	- 索引和数据保存在同一个文件中
	- 页内记录按照主键大小排序排成一个单向链表
	- 页和页之间根据主键大小排序成一个双向链表
	- 非叶子节点存储记录主键和页号
	- 叶子节点存储完整的用户记录
	- 优点
		- 数据访问更快
		- 对于主键排序查找和范围查找非常快
		- 查询一定范围数据是，由于数据相连，可以从更少数据快中提取数据，节省IO操作
	- 缺点
		- 插入速度依赖插入顺序，按照主键顺序插入最快，否则会出现页分裂，影响性能
		- 更新主键代价非常高，将导致被更新的行移动
	- 限制
		- 只有InnoDB支持，MyISAM不支持
		- 每个表只能有一个
		- 没有定义主键时将选取非空唯一列代替，没有就隐式定义一个主键rowID
		- 为了充分利用，表中主键应该选择有序的ID，不建议使用UUID，MD5，Hash，字符串作为主键
	- 查找和匹配逻辑
		- 根据第一层对应的范围找到第二层的页地址
		- 根据第二层的数据找到对应的下一层页地址，直到找到record_type=0存放普通数据的叶子节点的页地址
		- 再叶子节点上定位到对应的数据
- 非聚簇索引
	- 非主键索引外的其他索引
	- 页间的记录根据所选类的大小排序
	- 页和页也是通过双向链表连接的
	- 非叶子节点记录数据值和页号
	- 非叶子节点存储数据值和主键
	- 可以有多个
	- 查找匹配逻辑
		- 查找的过程与聚簇索引前面一样
		- 找到对应记录的主键数值
		- 根据主键值去聚簇索引中查找一遍
- 和，二叉树，平衡二叉树，红黑树，B树的区别
	- 二叉树
		- 不能平衡，容易变成链表
	- 平衡二叉树
		- 可以通过自旋转保证左右两边高度平衡
		- 树的高度过高
	- 红黑树
		- 自旋速度比较快
		- 非严格平衡二叉树
	- B树
		- 非叶子节点页存储数据
- 一个B+树存放多少索引记录
	- 三层千万级别
	- 数据占用1KB，指针和键值10字节
	- 16x1600x1600=40960000
- B+树crud效率如何
	- 新增和删除比较麻烦，需要更新索引，查询和更新效率高
	- O(lognN) N为高度
- 自适应哈希索引
	- InnoDB一个特殊功能，某些索引值使用非常频繁会再内存中基于B+树所有值之上创建一个哈希索引，从而具有哈希索引一些特点
- 2-3树，2-3-4树
	- 多叉树允许每个节点可以有更多的数据项和子节点，通过增加分叉减少树的高度