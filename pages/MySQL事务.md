- 数据库操作的最小单元
- 作为一个整体一起向系统提交
- 事务是一组不可拆分的操作集合
- ACID
	- 原子性
		- 要么都执行，要么都不执行
	- 一致性
		- 事务执行前后是从一个一致性状态到另一个一致性状态
	- 隔离性
		- 事务之间互不干扰
	- 持久性
		- 事务一旦完成修改永久保存
- 并发事务的问题
	- 脏读
		- 读取到了另一个事务未提交的数据
	- 丢失修改
		- 一个事务修改了这个数据，但是另一个事务也修改了这个数据，这个时候第一个事务的修改结果就丢失了
	- 不可重复读
		- 一个事务多次读取同一个数据，读取到的结果不一样
	- 幻读
		- 一个事务多次查询返回的结果总数不一样
- 避免事务的并发问题
	- 配置事务隔离级别
	- 读未提交
	- 读已提交
	- **可重复读**
	- 串行化
- 默认情况下使用默认的隔离级别，一致性要求高就使用较高的事务隔离级别
- 靠缓存可以提升事务隔离级别的性能
	- 有缓存只能提供高效读，不能保证数据即时一致性，还需要额外开销管理缓存
- 隔离实现方案
	- 读写锁
		- 锁定读，共享读锁之间不会排斥，写锁会排斥其他锁
		- 锁竞争时，要等待其中一个操作释放锁另一个才能获取锁
		- 行锁
		- 间隙锁
		- select lock in share mode
		- select lock for update
		- insert、update、delete
	- MVCC
		- 一致性非锁定读
		- 隐藏字段
			- DB_TRX_ID，标记最近一次对本行记录做修改的事务id
			- DB_ROLL_PTR，回滚指针，指向改行的undolog
			- DB_ROW_ID，没有主键和唯一列时会使用该id生成聚簇索引
		- Read View
			- 记录和隔离不同事物并发时此纪录哪些版本对当前事务可见
		- Undolog
			- 回滚数据，读取可见版本的数据
- 一致性、原子性如何实现
	- 通过MVCC实现
	- 灾备通过redolog实现，redolog会记录下来所有修改，崩溃后可以通过redolog恢复修改
- 持久性如何实现
	- redolog实现，事务提交的时候先将所有日志写入日志文件进行持久化，即WAL（write ahead log）机制