- [[谈谈你对AQS的理解]]
- [[lock和synchronized区别]]
- [[线程池如何知道一个线程的任务已经执行完成]]
- [[什么叫做阻塞队列的有界和无界]]
- [[ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？]]
- [[能谈一下CAS机制吗？]]
- [[死锁的发生原因和怎么避免]]
- [[讲一下wait和notify这个为什么要在synchronized代码块中？]]
- 你是怎么理解线程安全问题的？
- 什么是守护线程，它有什么特点
- 谈谈你对AQS的理解
- AbstractQueuedSynchronized 为什么采用双向链表
- lock和synchronized 区别
- 线程池如何知道一个线程的任务已经执行完成
- 什么叫做阻塞队列的有界和无界
- ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？
- 能谈一下CAS机制吗？
- 死锁的发生原因和怎么避免
- volatile 关键字有什么用？它的实现原理是什么？
- 讲一下wait和notify这个为什么要在synchronized代码块中？
- ThreadLocal是什么？它的实现原理呢？
- 基于数组的阻塞队列 ArrayBlockingQueue 原理
- 怎么理解线程安全？
- 请简述一下伪共享的概念以及如何避免
- 什么是可重入，什么是可重入锁？它用来解决什么问题？
- 请说一下ReentrantLock的实现原理？
- 简述一下你对线程池的理解？
- 如何中断一个正在运行的线程？
- 为什么引入偏向锁、轻量级锁，介绍下升级流程
- 什么是守护线程，它有什么特点
- 请谈谈AQS是怎么回事儿？
- ReentrantLock 是如何实现锁公平和非公平性的？
- 说一下你对 CompletableFuture的理解
- 线程状态，BLOCKED和WAITING有什么区别
- Thread和Runnable的区别
- Thread和Runnable的区别
- AQS为什么要使用双向链表？
- ConcurrentHashMap的size（）方法是线程安全的吗？为什么
- wait和sleep是否会触发锁的释放以及CPU资源的释放？
- DCL单例模式设计为什么需要 volatile 修饰实例对象
- 讲下线程池的线程回收
- 如果一个线程两次调用start（），会出现什么问题？
- Java 官方提供了哪几种线程池，分别有什么特点？
- 请你说一下你对Happens-Before的理解。
- 线程池是如何实现线程复用的？
- 可以说下阻塞队列被异步消费怎么保持顺序吗？
- 当任务数超过线程池的核心线程数时，如何让它不进入队列，而是直接启用最大线程数
- SimpleDateFormat 是线程安全的吗？为什么？
- 并行和并发有什么区别？
- 如何解决死锁问题？
- 为什么 ConcurrentHashMap中key不允许为null
- ThreadLocal会出现内存泄漏吗？
- 什么是CompletableFuture？
- 什么条件下会产出死锁，如何避免死锁？
- ConcurrentHashMap是如何保证线程安全的？
- ThreadLocal真的会造成内存泄漏吗？
- 为什么 ConcurrentHashMap 不允许插入null值？
- synchronized和Lock的区别
- 如何安全地中断一个正在运行的线程？