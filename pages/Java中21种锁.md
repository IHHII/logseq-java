- 乐观锁
	- 读多写少，写入时进行CAS操作
- 悲观锁
	- 写多读少，每一次读写都上锁
	- Synchronized ReentrantLock
- 自旋锁
	- 自旋空操作，避免线程切换开销
	- 等待时间过程会浪费性能
- 可重入锁
	- 可以多次获取同一个锁
	- ReentrantLock，Synchronized
	- 申请几把锁需要释放几把锁
- 读写锁
	- 读锁
		- 允许多个线程同时访问一个资源
	- 写锁
		- 只允许一个线程获取锁
- 公平锁
	- 多个线程按照申请锁的顺序获取锁
- 非公平锁
	- 多个线程获取锁的顺序不是一致的
	- 线程状态修改需要时间
	- 导致线程饥饿
	- synchronized，lock通过构造方法修改
- 共享锁
	- 和读锁，乐观锁类似
- 独占锁
	- 和写锁，悲观锁类似
- 重量级锁
	- 依赖操作系统的锁
	- synchronized通过监视器monitor实现，需要用户态和内核态切换
- 轻量级锁
	- 没有竞争时，通过CAS操作实现
	- 有竞争变为重量级锁
- 偏向锁
	- 偏向第一个获取的线程，如果没有竞争，就不需要进行CAS操作可以直接获取锁
	- 如果存在锁及大部分都是竞争的情况下是多余的
- 分段锁
	- jdk1.7，ConcurrentHashMap有16个segment
- 互斥锁
	- 和写锁、悲观锁、独占锁类似
- 同步锁
	- 互斥锁、写锁、悲观锁
	- 并发执行的多个线程，同一时间只有一个线程可以访问
- 死锁
	- 线程持有对方线程需要的自由，又都不释放自己的锁
- 锁粗化
	- 扩大加锁的范围，减少加锁的频率减少损耗
- 锁消除
	- 如果共享资源没有竞争就消除锁
	- 内存逃逸分析
- synchronized
	- 实例方法，方法，代码块
- lock
	- 接口，可重入锁，悲观锁，独占锁，互斥锁，同步锁
	- 需要手动释放
	- 发生异常没有主动释放锁很可能会死锁
	- 可以让等待锁的线程响应中断
	- 可以知道是否成功获取锁
	- 实现读写锁提高效率
- ReentrantLock和Synchronized
	- 都解决共享变量安全访问的问题
	- 可重入锁
	- 可见性，原子性
	- 手动调用lock和unlock
	- 响应中断
	- API，JVM
	- 公平，非公平
	- ReentrantLock通过Condition绑定多个条件
-